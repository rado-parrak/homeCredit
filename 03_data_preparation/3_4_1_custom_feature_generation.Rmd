---
title: Custom Feature Generation
author: Rado
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  prettydoc::html_pretty:
    theme: architect
    highlight: github
---

```{r echo=FALSE, warning = FALSE, message = FALSE}
# Clean workspace and load libs:
rm(list = ls())
library(plyr)
library(dplyr)
library(smbinning)
library(ggplot2)
library(doParallel)
source('_utils.R')

sdata <- read.csv('./sanitized_data/s_application_train.csv', header = T)
```
# TO DOs:

    1. Currently WOE, IV and pre-selection only for quantitative. Similar should be done for categorical and indicators too...

# Intro

## Goal
Generation of features from loan application-level attributes

## Inputs
    - application_train.csv 
    - application_test.csv
    - ...

## Outputs
    - predictor_base_train.csv
    - predictor_base_test.csv

## Settings
```{r echo=TRUE, warning = FALSE, message = FALSE}
# Settings
pVal    <- 0.05 #pval for smbinning
IVtresh <- 0.05
```

# Variable imporance based on WOE and IV

## Overview

```{r echo=FALSE, warning = FALSE, message = FALSE}
# Quantitative variables
sdata_q <- dplyr::select(sdata, starts_with("Q_")) %>%
  dplyr::mutate(T_TARGET = sdata$T_TARGET)
ivContainer     <- list()

qnames            <- colnames(sdata_q)[colnames(sdata_q) != "T_TARGET"]
results_smBinning <- list()

# RADO: The idea here is to run various 'optimal binning' algos, save results,
# then select only those variables and "cuts" from a given binning algo that 
# give IV larger than IVtresh.
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
nParts <- 8
for(j in 1:nParts){ #this outer loop is there due to heap insuficiency
  minn <- (j-1)*ceiling(ncol(sdata_q)/nParts) + 1
  maxx <- min((j)*ceiling(ncol(sdata_q)/nParts),length(qnames))
  aux <- foreach(i = minn:maxx, .packages = c('smbinning')) %dopar% doSmBinning(qnames[[i]], sdata_q, pVal, IVtresh)
  print(paste0('=== Chunk >> ', minn, ':', maxx, ' from ', length(qnames),'. ==='))
  print(paste0('Start: ', Sys.time()))
        
  if(j == 1){
    results_smBinning <- aux
  } else{
    results_smBinning <- c(results_smBinning, aux)
  }
  results_smBinning <- plyr::compact(results_smBinning)
  rm(aux)
  print(paste0('End: ', Sys.time()))
}
stopCluster(cl)

# save the interesting vars from 'smBinning' to IV container
for(res in results_smBinning){
    ivContainer[[colnames(sdata_q)[res$col_id]]]$IV             <- res$iv
    ivContainer[[colnames(sdata_q)[res$col_id]]]$cuts           <- res$cuts
    ivContainer[[colnames(sdata_q)[res$col_id]]]$binningMethod  <- 'smBinning'
}

# prepare data for plot
counter <- 0
for(el in ivContainer){
  counter <- counter +1
  if(counter == 1){
    dataForPlot <- data.frame(variable = paste0(names(ivContainer)[counter], ' | ', el$binningMethod)
                              , IV = el$IV)
  }else{
    dataForPlot <- rbind(dataForPlot, data.frame(variable = paste0(names(ivContainer)[counter], ' | ', el$binningMethod)
                              , IV = el$IV))
  }
}

ggplot(data = dataForPlot, aes(x = reorder(variable, IV), y = IV)) +
  geom_bar(stat = 'identity') +
  coord_flip()

```

## Results for those with IV > IVtresh
```{r echo=FALSE, warning = FALSE, message = FALSE}
sel_qnames <- names(ivContainer)
for(i in 1:length(results_smBinning)){
  par(mfrow=c(2,2))
  varName <- names(ivContainer)[i]
  boxplot(sdata_q[,varName]~sdata_q$T_TARGET,horizontal=T, frame=F, col="lightgray",main="Distribution")
  smbinning.plot(results_smBinning[[i]],option="dist")
  smbinning.plot(results_smBinning[[i]],option="badrate")
  smbinning.plot(results_smBinning[[i]],option="WoE")
  mtext(varName, side = 3, line = -13, outer = TRUE)
}
```

## (bucketize and) Save
```{r echo=FALSE, warning = FALSE, message = FALSE}
# take all variables except quantitative
output <- cbind(T_TARGET = sdata$T_TARGET,sdata[,!(colnames(sdata) %in% colnames(sdata_q))])

# add only the important original variables
output <- cbind(output, sdata[,sel_qnames])

# add also the binned original variables
for(i in 1:length(results_smBinning)){
  namee               <- colnames(sdata_q)[results_smBinning[[i]]$col_id]
  new_namee           <- paste0('B_', namee, '_v1')
  output[,new_namee]  <- findInterval(sdata[,namee], vec = results_smBinning[[i]]$cuts) 
}

# save output
write.csv(output, file='./predictor_base/predictor_base_train.csv')
```
Output saved to '03_data_preparation/predictor_base'.