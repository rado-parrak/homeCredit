---
title: Custom Feature Generation
author: Rado
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  prettydoc::html_pretty:
    theme: architect
    highlight: github
---

```{r echo=FALSE, warning = FALSE, message = FALSE}
# Clean workspace and load libs:
rm(list = ls())
library(plyr)
library(dplyr)
library(smbinning)
library(woeBinning)
library(ggplot2)
library(doParallel)
source('_utils.R')

sdata <- read.csv('./sanitized_data/s_application_train.csv', header = T)
```
# TO DOs:

    1. Currently WOE, IV and pre-selection only for quantitative. Similar should be done for categorical and indicators too...

# Intro

## Goal
Generation of features from loan application-level attributes

## Inputs
    - application_train.csv 
    - application_test.csv
    - ...

## Outputs
    - predictor_base_train.csv
    - predictor_base_test.csv

## Settings
```{r echo=TRUE, warning = FALSE, message = FALSE}
# Settings
pVal        <- 0.05 #pval for sm- and woe-binning
IVtresh     <- 0.05
minPerClass <- 0.01
```

# Variable imporance based on WOE and IV

## Quantitative variables 

### Overview
```{r echo=FALSE, warning = FALSE, message = FALSE}
# Quantitative variables
sdata_q <- dplyr::select(sdata, starts_with("Q_")) %>%
  dplyr::mutate(T_TARGET = sdata$T_TARGET)

qnames            <- colnames(sdata_q)[colnames(sdata_q) != "T_TARGET"]
results_smBinning <- list()
results_WoeBinning <- list()

# RADO: The idea here is to run various 'optimal binning' algos, save results,
# then select only those variables and "cuts" from a given binning algo that 
# give IV larger than IVtresh.
cl <- makeCluster(detectCores() - 1)
registerDoParallel(cl)
nParts <- 10
log_con1 <- file("SmBinningLog.log", open = "a")
log_con2 <- file("WoeBinningLog.log", open = "a")
for(j in 1:nParts){ #this outer loop is there due to heap insuficiency
  print(paste0('Start: ', Sys.time()))
  minn <- (j-1)*ceiling(ncol(sdata_q)/nParts) + 1
  maxx <- min((j)*ceiling(ncol(sdata_q)/nParts),length(qnames))
  print(paste0('=== Chunk >> ', minn, ':', maxx, ' from ', length(qnames),'. ==='))
  
  aux_smBinning <- foreach(i = minn:maxx, .packages = c('smbinning')) %dopar% doSmBinning(qnames[[i]], sdata_q, pVal, IVtresh, './SmBinningLog.log')
  aux_woeBinning <- foreach(i = minn:maxx, .packages = c('woeBinning')) %dopar% doWoeBinning(qnames[[i]], sdata_q, pVal, IVtresh, minPerClass,'./WoeBinningLog.log')
  
  if(j == 1){
    results_smBinning   <- aux_smBinning
    results_WoeBinning  <- aux_woeBinning
  } else{
    results_smBinning   <- c(results_smBinning, aux_smBinning)
    results_WoeBinning  <- c(results_WoeBinning, aux_woeBinning)
  }
  results_smBinning <- plyr::compact(results_smBinning)
  results_WoeBinning <- plyr::compact(results_WoeBinning)
  
  rm(aux_smBinning, aux_woeBinning)
  print(paste0('End: ', Sys.time()))
}
stopCluster(cl)
close(log_con1)
close(log_con2)

# save the interesting vars from 'smBinning' to IV container
ivContainer       <- list()
for(res in results_smBinning){
    ivContainer[[paste0(colnames(sdata_q)[res$col_id], '_sm')]]$IV             <- res$iv
    ivContainer[[paste0(colnames(sdata_q)[res$col_id], '_sm')]]$cuts           <- res$cuts
    ivContainer[[paste0(colnames(sdata_q)[res$col_id], '_sm')]]$binningMethod  <- 'smBinning'
}

# save the interesting vars from 'WoeBinning' to IV container
for(res in results_WoeBinning){
    ivContainer[[paste0(res[[1]], '_woe')]]$IV             <- res[[2]]$iv.total.final[1] 
    ivContainer[[paste0(res[[1]], '_woe')]]$cuts           <- res[[2]]$cutpoints.final[-1]
    ivContainer[[paste0(res[[1]], '_woe')]]$binningMethod  <- 'woeBinning'
}

# prepare data for plot
counter <- 0
for(el in ivContainer){
  counter <- counter +1
  if(counter == 1){
    dataForPlot <- data.frame(variable = paste0(names(ivContainer)[counter], ' | ', el$binningMethod)
                              , IV = el$IV)
  }else{
    dataForPlot <- rbind(dataForPlot, data.frame(variable = paste0(names(ivContainer)[counter], ' | ', el$binningMethod)
                              , IV = el$IV))
  }
}

ggplot(data = dataForPlot, aes(x = reorder(variable, IV), y = IV)) +
  geom_bar(stat = 'identity') +
  coord_flip()

```

### Results for those with IV > IVtresh
```{r echo=FALSE, warning = FALSE, message = FALSE}
sel_qnames <- names(ivContainer)
for(i in 1:length(results_smBinning)){
  par(mfrow=c(2,2))
  varName <- names(ivContainer)[i]
  boxplot(sdata_q[,varName]~sdata_q$T_TARGET,horizontal=T, frame=F, col="lightgray",main="Distribution")
  smbinning.plot(results_smBinning[[i]],option="dist")
  smbinning.plot(results_smBinning[[i]],option="badrate")
  smbinning.plot(results_smBinning[[i]],option="WoE")
  mtext(varName, side = 3, line = -13, outer = TRUE)
}
```

## (bucketize and) Save
```{r echo=FALSE, warning = FALSE, message = FALSE}
# take all variables except quantitative
output <- cbind(T_TARGET = sdata$T_TARGET,sdata[,!(colnames(sdata) %in% colnames(sdata_q))])

# add only the important original variables
output <- cbind(output, sdata[,sel_qnames])

# add also the binned original variables
for(i in 1:length(results_smBinning)){
  namee               <- colnames(sdata_q)[results_smBinning[[i]]$col_id]
  new_namee           <- paste0('B_', namee, '_v1')
  output[,new_namee]  <- findInterval(sdata[,namee], vec = results_smBinning[[i]]$cuts) 
}

# save output
write.csv(output, file='./predictor_base/predictor_base_train.csv')
```
Output saved to '03_data_preparation/predictor_base'.